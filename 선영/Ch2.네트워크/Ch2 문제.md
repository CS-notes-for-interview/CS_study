# Ch.2 네트워크 문제

![![]](Ch2%20문제_assets/36b58dac82f3103e0b47ed94118d090f9b4dce1f.jpg)

#### OSI 7계층에서 계층마다 담당하는 계층 이름과 역할을 적으시오.

###### 1계층 - 물리계층(Physical Layer)

- 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 **물리적인 장비**
- 단지 데이터 전기적인 신호(0,1)로 변환해서 주고받는 기능만 할 뿐 전송하려는
  (또는 받으려는)**데이터가 무엇인지, 어떤 에러가 있는지 등에는 전혀 신경 쓰지 않는다.**
- 사용되는 통신 단위 : **비트(Bit)**, **1과 0**으로 나타내어지는, 즉 전기적으로 On, Off 상태
- 장비 : **통신 케이블, 리피터, 허브** 등

###### 2계층 - 데이터 링크계층(DataLink Layer)

- 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 **통신의 흐름을 관리**
- 프레임에 물리적 **주소(MAC address)** 를 부여하고 에러검출, 재전송, 흐름제어를 수행
- 이 계층에서 전송되는 단위 : 프레임(Frame)
- 장비 : **브리지, 스위치, 이더넷** 등(여기서 MAC주소를 사용)

→ **브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달함**.

###### **3계층 -** **네트워크 계층(Network Layer)**

- 데이터를 목적지까지 가장 안전하고 빠르게 전달
- 라우터(Router)를 통해 경로를 선택하고 주소를 정하고 **(IP)** 경로(Route)에 따라 패킷을 전달 > IP 헤더 붙음
- 이 계층에서 전송되는 단위 : **패킷(Packet)**
- 장비 : **라우터**

###### 4계층 - 전송 계층(Transport Layer)

- **port 번호**, 전송방식 **(TCP/UDP)** 결정 > **TCP 헤더** 붙음
  - TCP : 신뢰성, 연결지향적
  - UDP : 비신뢰성, 비연결성, 실시간
- 두 지점간의 **신뢰성** 있는 데이터를 주고 받게 해주는 역할
- 신호를 분산하고 다시 합치는 과정을 통해서 에러와 경로를 제어

###### 5계층 - 세션 계층(Session Layer)

- 주 지점간의 프로세스 및 통신하는 호스트 간의 연결 유지
- TCP/IP 세션 체결, 포트번호를 기반으로 **통신 세션** 구성
- API, Socket

###### 6계층 - 표현 계층(Presentation Layer)

- 전송하는 **데이터의 표현방식**을 결정(ex. 데이터변환, 압축, 암호화 등)
- 파일인코딩, 명령어를 포장, 압축, 암호화
- JPEF, MPEG, GIF, ASCII 등

###### 7계층 - 응용 계층(Application Layer)

- 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행(ex. explore, chrome 등)
- HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.

#### TCP/IP 4계층에서 계층마다 담당하는 계층이름과 역할을 적으시오.

###### 1계층 - 네트워크 액세스 계층(Network Access Layer)

- OSI 7계층의 **물리계층(1)과 데이터 링크 계층(2)** 에 해당

- TCP/IP 패킷을 네트워크 매체로 전달하는 것과 네트워크 매체에서 TCP/IP 패킷을 받아들이는 과정을 담당

- 에러 검출 기능(Detecting errors), 패킷의 프레임화(Fraimg packets)

- 네트워크 접근 방법, 프레임 포맷, 매체에 대해 독립적으로 동작하도록 설계.

- 물리적인 주소로 **MAC**을 사용

- LAN, 패킷망, 등에 사용됨

###### 2계층 - 인터넷 계층(Internet Layer)

- OSI 7계층의 네트워크 계층(3)에 해당

- 어드레싱(addressing), 패키징(packaging), 라우팅(routing) 기능을 제공

- 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공하게 됨.

- 프로토콜 종류 – IP, ARP, RARP

###### 3계층 - 전송 계층(Transport Layer)

- OSI 7계층의 전송 계층(4)에 해당

- **IP와 Port**를 이용하여 프로세스와 통신

- 애플리케이션 계층의 세션과 데이터그램(datagram) 통신서비스 제공

- 통신 노드 간의 연결을 제어하고, **신뢰성** 있는 데이터 전송을 담당한다.

- 프로토콜 종류 – TCP, UDP

###### 4계층 - 응용 계층(Application Layer)

- OSI 7계층의 **세션 계층(5), 표현 계층(6), 응용 계층(7)** 에 해당한다.

- 프로그램(브라우저)가 직접 인터액트하는 레이어. 데이터를 처음으로 받는곳

- 다른 계층의 서비스에 접근할 수 있게 하는 애플리케이션을 제공

- 애플리케이션들이 데이터를 교환하기 위해 사용하는 프로토콜을 정의

- HTTP, SMTP등의 프로토콜을 가진다.

- TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.

- 프로토콜 종류 – FTP, HTTP, SSH

#### OSI 7계층과 TCP/IP 4계층의 공통점과 차이점을 적으시오.

- TCP/IP 프로토콜은 OSI 모델보다 먼저 개발되었다. 

- 두 모델 모두 계층형 이라는 공통점을 가지고 있으며 TCP/IP는 인터넷 개발 이후 계속 표준화되어 신뢰성이 우수인 반면, OSI 7 Layer는 표준이 되기는 하지만 실제적으로 구현되는 예가 거의 없어 신뢰성이 저하되어있다.

- OSI 7 Layer는 장비 개발과 통신 자체를 어떻게 표준으로 잡을지 사용되는 반면에 실질적인 통신 자체는 TCP/IP 프로토콜을 사용한다.

#### HTTPS에 대해 설명하고 HTTP와 비교하였을 때의 HTTPS의 장점과 차이점을 설명하시오

HTTPS는 기본 골격이나 사용 목적 등은 HTTP와 거의 동일하지만, 데이터를 주고 받는 과정에 ‘보안’ 요소가 추가되었다는 것이 가장 큰 차이점이다. HTTPS를 사용하면 **서버와 클라이언트 사이의 모든 통신 내용이 암호화**된다.

- HTTPS는 웹사이트의 무결성을 보호해준다. 웹 사이트와 사용자 브라우저 사이의 통신을 침입자가 건드리지 못하도록 한다. (침입자라함은, 악의가 있는 공격자는 물론이고, 합법이지만 통신에 침입하여 페이지에 광고를 삽입하는 경우도 해당한다.)
- 가벼운 웹 서핑이라면 HTTP도 상관없지만, 사용자의 정보를 웹 서버와 주고 받아야하는 경우라면 HTTP는 정보 유출의 위험성을 갖게 된다. HTTPS는 침입자가 웹사이트와 사용자 사이의 통신을 몰래 수신하는 것을 방지함으로써 보안을 강화해준다.
- `getUserMedia()`를 통한 사진 촬영이나 오디오 녹음, 프로그레시브 웹 앱과 같은 강력한 웹 플랫폼 신기능들은 실행하려면 사용자의 명시적인 권한 허락을 필요로 한다. [지오로케이션](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) API와 같은 오래된 API들도 실행할 때 권한이 필요하도록 업데이트되고 있는데, HTTPS는 이러한 새 기능과 업데이트된 API에 대한 권한 허락을 가능하게 한다.
- 네이버, 다음은 물론이고 구글 역시 검색 엔진 최적화(SEO: Search Engine Optimization) 관련 내용을 HTTPS 웹사이트에 대해서 적용하고 있다. 즉, 키워드 검색 시 상위 노출되는 기준 중 하나가 보안 요소이다.
- 모든 사이트에서 텍스트를 암호화해서 주고 받으면 과부하가 걸려 속도가 느려질 수 있다. 중요한 사이트는 HTTPS로 관리하고, 그렇지 않은 사이트는 HTTP를 사용한다.
- HTTPS를 지원한다고 해서 무조건 안전한 것은 아니다. 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문이다.

#### HTTP1.0, HTTP1.1, HTTP2 각각의 특징을 설명하시오

###### HTTP1.0

기존의 HTTP 1.0은 TCP Connection당 하나의 URL만 fetch하며, 매번 request/response가 끝나면 연결이 끊기므로 필요할 때마다 다시 연결해야하는 단점이 있어 속도가 현저히 느리다.

- 매번 새로운 연결로 성능 저하
- 서버 부하 비용 증가
- GET, HEAD, POST의 method가 사용된다.
  - HEAD는 Header의 정보만 전송된다.

###### HTTP1.1

- **persistent Connection(keep-alive)**
  - 지정한 timeout 동안 커넥션을 닫지 않는다.
  - 기본적으로 keep-alive이고 사용하지 않을 때만 헤더에 ~을추가하여 사용하지 않는다.
- 캐시를 두어 성능을 향상시켰고 데이터를 압축해서 보낸다.
- OPTION, PUT, DELETE, TRACE의 method를 사용한다.
- multiple request에 대한 처리가 가능하고 request/response가 파이프라인 방식으로 진행이 가능하다.(하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답하여 지연 시간을 줄인다)
- 호스트 헤더를 통해서 Virtual Hosting 이 가능해졌다.
  - 한 ip로 여러 도메인을 운영할 수 있다.

###### HTTP2.0

HTTP 1.X는 평문을 사용했지만 2.0부터는 바이너리 포맷으로 인코딩된 Message, Frame 으로 구성된다. 즉, 바이너리로 전달한다.

메시지 전송 방식의 변화

- 바이너리 프레이밍 계층 사용 - 파싱, 전송 속도 증가 (바이너리로 전달하므로)
- Multiplexed Streams: 요청과 응답에 멀티플렉싱이 가능하다. - 바이너리 프레임으로 나누고 잔송받은 쪽에서 다시 조립한다.( 받는 쪽에서 다시 조립하므로 요청과 응답의 순서가 중요하지 않으므로 HOLB해결)
- Stream Prioritization - 리소스간 우선순위 설정 가능
- Server push - 클라이언트가 요청하지 않는 리소스도 push 가능하다.
- Header Compression - 헤더의 크기를 줄인다.(중복 제거) 약 85%
- HTTP1.X가 결국 지연시켜서 한 번에 요청/응답을 처리하는 방식에서 2.0부터는 각 응답을 멀티플렉싱 즉, frame으로 나누어서 병렬로 처리할 수 있다.

#### 쿠키와 세션의 차이에 대해 설명하시오

###### 쿠키

HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우,

그 사이트가 사용하고 있는 서버에서 **사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**이다.

HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 **필요시 정보를 참조하거나 재사용할 수 있다.**

- **쿠키 특징**
  1. 이름, 값, 만료일(저장기간), 경로 정보로 구성되어 있다.
  2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
  3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
  4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.
- **쿠키의 동작 순서**
  1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트에 접근)
  2. 웹 서버는 쿠키를 생성한다.
  3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다.
  4. 넘겨받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장) 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
  5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송한다.
- **사용 예시**
  1. 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
  2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크

###### 세션

일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술이다.

여기서 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.

즉, **방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.**

- **세션 특징**
  
  1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
  2. 웹 서버의 저장되는 쿠키(=세션 쿠키)
  3. 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다.
  4. 저장 데이터에 제한이 없다. (서버 용량이 허용하는 한에서)
  5. 각 클라이언트에 고유 Session ID를 부여한다. Session ID로 클라이언트를 구분해 각 요구에 맞는 서비스를 제공

- **세션의 동작 순서**
  
  1. 클라이언트가 페이지에 요청한다.
  
  2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 클라이언트가 해당 session-id를 보냈는지 확인한다.
  
  3. session-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 넘겨준다.
  
  4. 클라이언트는 서버로부터 받은 session-id를 쿠키에 저장한다.
  
  5. 클라이언트는 서버에 요청시 이 쿠키의 session-id 값을 같이 서버에 전달한다.  
  
  6. 서버는 전달받은 session-id로 session에 있는 클라이언트 정보를 가지고 요청을 처리 후 응답한다.

- **사용 예시**
  
  - 화면을 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

###### 쿠키와 세션의 차이

- 쿠키와 세션은 비슷한 역할을 하며, 동작 원리도 비슷하다. 그 이유는 세션도 결국 쿠키를 사용하기 때문이다.
- 큰 차이점은 **사용자의 정보가 저장되는 위치**이다. 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용한다.
- 보안 면에서 세션이 더 우수하며,
- 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만
- 세션은 쿠키를 이용해서 session-id만 저장하고 그것으로 구분하여 서버에서 처리하기 때문에 비교적 보안성이 높다.
- **라이프 사이클**은 쿠키도 만료기간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 정보가 유지될 수 있다. 또한 만료기간을 따로 지정해 쿠키를 삭제할 때까지 유지할 수도 있다.
- 반면에 세션도 만료기간을 정할 수 있지만, 브라우저가 종료되면 만료기간에 상관없이 삭제된다.
- 속도 면에서 쿠키가 더 우수하며,
- 쿠키는 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르고
- 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

보통 쿠키와 세션의 차이에 대해서 저장 위치와 보안에 대해서는 잘 알고 있지만, 사실 가장 중요한 것은 **라이프사이클**이다.

#### www.google.com에 접속할 때 생기는 과정에 대해 설명해주세요.(웹 동작 방식 이해)

1. 입력한 URL 주소 중, 도메인 이름에 해당하는 google.com를 DNS 서버에서 검색

2. 가장 가까운 DNS 서버에서 해당 도메인 이름에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달

3. 전달받은 IP주소를 이용하여 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 html문서를 요청

4. WAS와 데이터베이스에서 웹페이지 작업을 처리

5. WAS에서의 작업 처리 결과들을 웹 서버로 전송하고, 웹 서버는 웹 브라우저에게 html 문서 결과를 전달

6. Critical Rendering Path를 통해 웹 브라우저 화면에 웹 페이지 내용을 출력

7. DOM 트리 빌드

8. CSSOM 트리 빌드

9. DOM과 CSSOM을 결합하여 Render Tree 생성

10. Layout : Render Tree의 노드들에 대한 위치와 크기를 계산

11. Paint : 레이아웃 단계에서 계산된 모든 위치와 크기를 실제 픽셀로 변환하여 화면에 출력
    
    11. 5Reflow & Repaint

12. Composition : 레아아웃과 페인트를 수행하지 않고 레이어의 합성만 실행시키는 단계

13. URL에 맞는 화면이 웹 브라우저에 출력됨

#### TCP와 UDP의 차이를 설명하시오.

![!](Ch2%20문제_assets/f9d04c86840204435d7ed2e4c0ac8aa5db724145.PNG)

TCP는 연속성보다 신뢰성 있는 전송이 중요할 때 사용되는 프로토콜이며,

UDP는 TCP보다 빠르고 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터 전송을 보장하지는 않는다.

그렇기 때문에 신뢰성보다는 연속성이 중요한 실시간 스트리밍과 같은 서비스에 자주 사용된다.

#### 3웨이 핸드셰이크와 4-웨이 핸드셰이크에 대해 설명하시오.

###### 3-way Handshaking![!](Ch2%20문제_assets/4fbffd6e1dd9993a90cdd7a69b88bb7770ac8147.png)

**[STEP 1]**

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다.

이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 **SYN_SENT** 상태, **B서버는 Wait for Client** 상태이다.

**[STEP 2]** 

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고

A가 다시 ACK으로 응답하기를 기다린다. 이때 **B서버**는 **SYN_RECEIVED** 상태가 된다.

**[STEP 3]**

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다.

이때의 **B서버 상태가 ESTABLISHED** 이다.

위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.

###### 4-way Handshaking

![!](Ch2%20문제_assets/3ab8831901b4d9172f2aac8c7d78fd1cba13e9fd.png)

**[STEP 1]**

클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 이때 **A클라이언트는  FIN-WAIT** 상태가 된다.

**[STEP 2]** 

B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가

**B서버의 CLOSE_WAIT**상태다.

**[STEP 3]**

연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 FIN플래그를 전송한다. 이때 B서버의 상태는 **LAST-ACK**이다.

**[STEP 4]**

클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.

**A클라이언트의 상태가 FIN-WAIT -> TIME-WAIT** 으로 변경된다.



3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면, 

4-Way handshake는 세션을 종료하기 위해 수행되는 절차이다!

#### 대칭키, 비대칭키 암호와 방식에 대해 설명하시오.

###### 대칭키 : 암/복호화에 사용되는 키가 동일함

- 장점 : **암호화방식에 속도가 빠르다.** **대용량 Data 암호화**에 적합하다.
- 단점 : 키를 교환해야 하는 문제, **탈취 관리 걱정**, 사람이 증가할수록 키관리가 어려워짐, 확장성 떨어짐
- Session Key, Secret Key, Shared Key, 대칭키, 단용키라고도 함
- **기밀성을 제공**하나, **무결성/인증/부인방지 를 보장하지 않음**
- 대표적 알고리즘 : 공인인증서의 암호화방식으로 유명한 **SEED**, DES, 3DES, AES, ARIA, 최근 주목받고 있는 암호인 ChaCha20

###### 비대칭키 : 암/복호화에 사용되는 키가 서로 다르며, 공개키 암호화라고도 함

- 단점 : **속도가 느림**
- 장점 : 키분배 필요 X, **기밀성/인증/부인방지 기능 제공**
- 방식
  - **암호 모드** : 송신자 공개키로 암호화 -> 송신자 사설키로 복호화  
    소량의 메시지 암호화 목적, 주로 키 교환의 용도로 사용
  - **인증 모드** : 송신자 사설키로 암호화 -> 송신자 공개키로 복호화  
    메시지를 인증(부인방지)하는 것이 목적
- 대표적인 알고리즘
  - **Diffie Hellman** : 최초의 공개키 알고리즘, 위조에 취약
  - **RSA** : 대표적 공개키 알고리즘
  - **DSA** : 전자서명 알고리즘 표준
  - **ECC** : 짧은 키로 높은 암호 강도, 빠른 구현 가능 PDA, 스마트폰등에 사용
